/**
 * @agentgate/core - AgentStore Interface
 *
 * Defines the storage interface that all backends must implement.
 * Includes methods for agents, challenges, and cleanup.
 */

import type { Agent, AgentStatus, ChallengeData, RateLimitConfig } from "../types.js";

// ---------------------------------------------------------------------------
// Agent Creation Input
// ---------------------------------------------------------------------------

/** Data required to create a new agent record. */
export interface CreateAgentInput {
  /** Unique agent ID (generated by the system) */
  id: string;
  /** Base64-encoded Ed25519 public key */
  publicKey: string;
  /** Optional x402 wallet address */
  x402Wallet?: string;
  /** Granted scope IDs */
  scopesGranted: string[];
  /** SHA-256 hash of the API key (hex encoded) */
  apiKeyHash: string;
  /** Rate limit configuration */
  rateLimit: RateLimitConfig;
  /** Agent metadata (framework, version, name, etc.) */
  metadata: Record<string, string>;
}

/** Data for updating an existing agent record. All fields optional. */
export interface UpdateAgentInput {
  /** Update granted scopes */
  scopesGranted?: string[];
  /** Update rate limit */
  rateLimit?: RateLimitConfig;
  /** Update reputation score */
  reputation?: number;
  /** Update metadata (merged with existing) */
  metadata?: Record<string, string>;
  /** Update agent status */
  status?: AgentStatus;
  /** Update last auth timestamp */
  lastAuthAt?: Date;
  /** Increment total request count */
  incrementRequests?: number;
  /** Increment total x402 paid amount */
  incrementX402Paid?: number;
}

// ---------------------------------------------------------------------------
// AgentStore Interface
// ---------------------------------------------------------------------------

/**
 * Storage interface for AgentGate.
 *
 * Implementations include:
 * - MemoryStore (in-memory Map, for dev/testing)
 * - SQLiteStore (better-sqlite3)
 * - PostgresStore (pg / @neondatabase/serverless)
 * - RedisStore (ioredis)
 *
 * All methods are async to support database-backed implementations.
 */
export interface AgentStore {
  // -----------------------------------------------------------------------
  // Agent CRUD
  // -----------------------------------------------------------------------

  /**
   * Create a new agent record.
   *
   * @param input - Agent creation data
   * @returns The created Agent record
   * @throws DuplicateAgentError if public key or wallet already exists
   */
  createAgent(input: CreateAgentInput): Promise<Agent>;

  /**
   * Get an agent by its ID.
   *
   * @param id - Agent ID (e.g. "ag_xxx")
   * @returns The Agent record, or null if not found
   */
  getAgent(id: string): Promise<Agent | null>;

  /**
   * Look up an agent by the hash of their API key.
   * Used for authenticating requests with Bearer API keys.
   *
   * @param apiKeyHash - SHA-256 hex hash of the API key
   * @returns The Agent record, or null if not found
   */
  getAgentByApiKeyHash(apiKeyHash: string): Promise<Agent | null>;

  /**
   * Look up an agent by their public key.
   * Used to check for duplicate registrations.
   *
   * @param publicKey - Base64-encoded Ed25519 public key
   * @returns The Agent record, or null if not found
   */
  getAgentByPublicKey(publicKey: string): Promise<Agent | null>;

  /**
   * Update an existing agent record.
   *
   * @param id - Agent ID
   * @param input - Fields to update
   * @returns The updated Agent record
   * @throws AgentNotFoundError if agent doesn't exist
   */
  updateAgent(id: string, input: UpdateAgentInput): Promise<Agent>;

  /**
   * Delete an agent record.
   *
   * @param id - Agent ID
   * @returns true if the agent was deleted, false if not found
   */
  deleteAgent(id: string): Promise<boolean>;

  // -----------------------------------------------------------------------
  // Challenge Management
  // -----------------------------------------------------------------------

  /**
   * Store a registration challenge.
   *
   * @param challenge - Challenge data to store
   */
  createChallenge(challenge: ChallengeData): Promise<void>;

  /**
   * Retrieve a challenge by agent ID.
   * Returns the most recent challenge for the given agent.
   *
   * @param agentId - Agent ID
   * @returns The ChallengeData, or null if not found
   */
  getChallenge(agentId: string): Promise<ChallengeData | null>;

  /**
   * Delete a challenge (after successful verification or expiry).
   *
   * @param agentId - Agent ID whose challenge to delete
   */
  deleteChallenge(agentId: string): Promise<void>;

  /**
   * Remove all expired challenges.
   * Should be called periodically for cleanup.
   *
   * @returns Number of challenges cleaned up
   */
  cleanExpiredChallenges(): Promise<number>;

  // -----------------------------------------------------------------------
  // Lifecycle
  // -----------------------------------------------------------------------

  /**
   * Close any open connections and clean up resources.
   * Called during server shutdown.
   */
  close?(): Promise<void>;
}
